---
title: 数据访问层
tags: 记笔记
date: 2018-06-19 15:50:43
---


## DatabaseConnection

数据库连接4要素
```java
//驱动
private static final String DBDRIVER = "com.mysql.jdbc.Driver";//驱动名
//连接（协议、ip、端口、数据库、参数）
private static final String DBURL = "jdbc:mysql://10.170.176.232:3306/bookstore";
//用户名
private static final String DBUSER = "bookstore";
//密码
private static final String DBPASSWORD = "bookstoreMySQL2015";
```
构造方法
```java
public DatabaseConnection() throws Exception {// 在构造方法中进行数据库连接
    Class.forName(DBDRIVER); // 加载数据库驱动
    this.conn = DriverManager.getConnection(DBURL, DBUSER, DBPASSWORD);// 连接数据库
}
```
公共方法
> 外部调用以获取数据库访问连接，以及关闭获取的数据库连接
```java
public Connection getConnection() {//取得数据库连接
    return this.conn;
}
public void close() throws Exception {//数据库关闭操作
    if (this.conn != null) {		//避免空指针
        this.conn.close();		//数据库关闭
    }
}
```
## DaoImpl
简介
> 该层封装了对数据库中各数据库表的操作sql，为Service层提供接口。
> 外接调用需要传入数据库连接,供Proxy层调用，该层只提供sql操作方法，不提供事务控制、监控等。
## DaoProxy
> proxy层向上提供数据访问接口，向下调用DaoIml的接口，在该层可以控制事务，计时等代理需求，做到与Dao层解耦的目的。
## DaoFactory
> 该类向外提供Proxy的实例，但设计上存在很大问题，每一次外接调用该类下的方法都活创建一个DaoProxy的实例，并且每个实例都会跟数据库建立一个链接。
> 而每次调用完毕后又将数据库连接关闭。要知道，建立一个数据库连接占用的计算机资源是比较大的，而如此频繁的创建关闭势必会造成数据访问异常缓慢的情况。

个人意见
> 数据库连接的建立与关闭交给数据库连接池管理，利用`ThreadLocal`将数据库连接与线程绑定，来解决多线程安全问题。

业务流程过于基础，不做说明。

附：
主流架构
![Socket](https://raw.githubusercontent.com/a347807131/blog/master/ms/structure.jpeg)

## JDBC

```java
//与具体的数据库解耦
public class JdbcUtil {

	private static String driverClass;
	private static String url;
	private static String user;
	private static String password;
	
	static{
		try {
			InputStream in = JdbcUtil.class.getClassLoader().getResourceAsStream("dbcfg.properties");
			Properties props = new Properties();
			props.load(in);
			
			driverClass = props.getProperty("driverClass");
			url = props.getProperty("url");
			user = props.getProperty("user");
			password = props.getProperty("password");
			Class.forName(driverClass);
		} catch (Exception e) {
			throw new ExceptionInInitializerError(e);
		}
		
	}

	public static Connection getConnection() {
		try {
			Connection conn = DriverManager.getConnection(url,user,password);
			return conn;
		} catch (SQLException e) {
			throw new RuntimeException(e);
		}
	}

	public static void release(ResultSet rs, Statement stmt, Connection conn) {
		if (rs != null) {
			try {
				rs.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
			rs = null;
		}
		if (stmt != null) {
			try {
				stmt.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
			stmt = null;
		}
		if (conn != null) {
			try {
				conn.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
			conn = null;
		}
	}
}
```

## TransactionManager
```java
//事务管理器 解耦
public class TransationManager {
	private static ThreadLocal<Connection> tl = new ThreadLocal<Connection>();
	public static Connection getConnection(){
		Connection conn = tl.get();//从当前线程上获得链接
		if(conn==null){
			conn = DBCPUtil.getConnection();
			tl.set(conn);//把链接绑定到当前线程上
		}
		return conn;
	}
	public static void startTransaction(){
		Connection conn = getConnection();
		try {
			conn.setAutoCommit(false);
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}
	public static void commit(){
		Connection conn = getConnection();
		try {
			conn.commit();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}
	public static void rollback(){
		Connection conn = getConnection();
		try {
			conn.rollback();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}
	public static void release(){
		Connection conn = getConnection();
		try {
			conn.close();
			tl.remove();//与线程池有关，解除关系
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}
}
```

## 对象代理工厂
```java
public class BeanFactory {
	/**
	 * 产生BusinessService的实例
	 * @param isProxy ture，返回代理类。false，原来的类
	 * @return
	 */
	public static BusinessService getBusinessService(boolean isProxy){
		final BusinessService s = new BusinessServiceImpl();
		if(isProxy){
			//返回实现的代理类
			BusinessService proxyS = (BusinessService)Proxy.newProxyInstance(s.getClass().getClassLoader(), 
					s.getClass().getInterfaces(), new InvocationHandler() {
						
						@Override
						public Object invoke(Object proxy, Method method, Object[] args)
								throws Throwable {
							Object rtValue = null;
							try{
								long time = System.currentTimeMillis();
								TransationManager.startTransaction();
								rtValue = method.invoke(s, args);
								TransationManager.commit();
								System.out.println(method.getName()+" cost time "+(System.currentTimeMillis()-time) +" millis second");
							} catch (Exception e) {
									TransationManager.rollback();
									throw new RuntimeException(e);
							}finally{
									TransationManager.release();
							}
							return rtValue;
						}
					});
			return proxyS;
		}else{
			return s;
		}
	}
}
```

## 达到的目的

- 默认就开启了事务支持
- 高度解耦
```java
public class Test{
    public void t1(){
    	BusinessService s = BeanFactory.getBusinessService(true);
    		System.out.println(s.getClass().getName());
    		s.transfer("aaa", "bbb", 100);
    }
}
```